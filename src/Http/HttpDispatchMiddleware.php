<?php
/*
 * (c) Leonardo Brugnara
 *
 * Full copyright and license information in LICENSE file.
 */

namespace Gekko\Http;

use \Gekko\DependencyInjection\IDependencyInjector;

class HttpDispatchMiddleware implements IHttpMiddleware
{
    /**
     * Dependency Injector class used to resolve dependencies
     *
     * @var \Gekko\DependencyInjection\IDependencyInjector
     */
    private $injector;

    public function __construct(IDependencyInjector $injector)
    {
        $this->injector = $injector;
    }

    public function apply(IHttpRequest $req, IHttpResponse $resp, callable $next)
    {
        if ($req == null || $resp == null) {
            throw new Exception("Missing parameters for middleware " . __CLASS__);
        }

        // If the route is null, the router has failed to enroute the request
        // we need to return 404
        if (!$this->injector->getContainer()->has(Routing\Route::class)) {
            $resp->setStatusLine("HTTP/1.1 404 Resource not found");
            $resp->setBody("Resource not found");
            return $next($req, $resp);
        }

        // If it is not an exception, get the handler function/object
        $route = $this->injector->make(Routing\Route::class);
        $handler = $route->getHandler();

        if ($handler == null) {
            $resp->setStatusLine("HTTP/1.1 404 Resource not found");
            $resp->setBody("Resource not found");
            return $next($req, $resp);
        }

        // Map HttpRequest parameters based on $handler signature
        $args = $this->mapParameters($req, $handler, $route->getParameters() ?? []);

        // Get an invokable object using DI to resolve dependencies. $invokable
        // will get the $args bound to it, every call to $invokable will use
        // the $args passed to the DI
        $invokable = $this->injector->make($handler, $args ?: []);

        // Obtain all the output generated by the handler and append it to the
        // HttpResponse body
        ob_start();
        $result = $invokable();
        $ob = ob_get_clean();
        if (!($result instanceof IHttpResponse))
        {
            $resp->appendToBody($result ?? $ob ?? "");
        }
        else if ($result !== $resp)
        {
            $resp->setStatusLine($result->getStatusLine());
            $resp->setHeaders($result->getHeaders());
            $resp->setCookies($result->getCookies());
            $resp->setBody($result->getBody());
        }
        return $next($req, $resp);
    }

    public function mapParameters(IHttpRequest $http_request, $handler, Routing\RouteParams $routeParams)
    {
        $method_params = $this->methodSignature($handler);
        if (empty($method_params)) {
            return [];
        }

        $query_parameters = [];
        $body_parameters = [];

        // Parse the query string
        $query = $http_request->getURI()->getQuery();
        if (strlen($query) > 0)
            parse_str($query, $query_parameters);
        
        $content_type = $http_request->getHeader('Content-Type');
        $body = $http_request->getBody();

        if ($content_type === "application/json")
            $body_parameters = json_decode($body, true);
        else if ($content_type === "application/x-www-form-urlencoded")
            parse_str($body, $body_parameters);

        $args = [];
        $unnamedParamsIndex = 0;
        foreach ($method_params as $i => $method_param) {
            $class      = $method_param['class'];   // If param has class then, their name, else the value is "mixed"
            $name       = $method_param['name'];    // Param name. Is used in search like key in $_REQUEST
            $optional   = $method_param['optional'];// If param is optional
            $hasDefault = array_key_exists("default", $method_param); //isset($method_param['default']) || is_null($method_param['default']);
            $default    = $hasDefault ? $method_param['default'] : null;

            $val = null;
            // Look for route parameters using the name (named parameters)
            if ($routeParams->has($name)) {
                $val = $routeParams[$name];
            } // Look for parameters in request body
            else if (isset($body_parameters[$name])) {
                $val = $body_parameters[$name];
            } // Look for parameters in the query
            else if (isset($query_parameters[$name])) {
                $val = $query_parameters[$name];
            } // Look for route parameters using an index-based aproach
            else if ($routeParams->has($unnamedParamsIndex)) {
                $val = $routeParams[$unnamedParamsIndex];
                $unnamedParamsIndex++;
            }

            // DI will resolve the dependency or will throw an error if it cannot resolve the parameter
            if ($val === null && !$optional) {
                continue;
            }

            // Use the default value if no value is provided
            if ($val == null && $hasDefault) {
                $val = $default;
            } // If parameter has an specific class and it implements IRequestParameter, try to create an instance using
            // the IRequestParameter::newInstance method.
            // If class does not implement the interface, try using the generic RequestParameter::tryNewInstanceOf.
            // If $val finally is null, dependency injector will try to instantiate a class object, passing $val
            // as arguments for the class constructor.
            else if ($class != 'mixed' && class_exists($class)) {
                if (in_array(IRequestParameter::class, class_implements($class))) {
                    $tmpval = $class::newInstance($val);
                } else {
                    $tmpval = RequestParameter::tryNewInstanceOf($class, $val);
                }

                if ($tmpval !== null) {
                    $val = $tmpval;
                } else {
                    $refclass = new \ReflectionClass($class);
                    $target = $refclass->newInstanceWithoutConstructor();
                    \Closure::bind(function() use (&$val) {
                        foreach ($val as $p => $v)
                            $this->{$p} = $v;
                    }, $target, $target)->__invoke();

                    $val = $target;
                }
            }

            $args[$name] = $val;
        }

        return $args;
    }

    public function methodSignature($method)
    {
        if (is_array($method)) {
            $method = new \ReflectionMethod($method[0], $method[1]);
        } else {
            $method = new \ReflectionFunction($method);
        }

        $metadata = [];
        $params = $method->getParameters();
        if (empty($params)) {
            return [];
        }
        
        $i = 0;
        foreach ($params as $param) {
            $param_class = $param->getClass();
            $metadata[$i]['class'] = !empty($param_class) ? $param_class->name : "mixed";
            if ($param->isDefaultValueAvailable()) {
                $metadata[$i]['default'] = $param->getDefaultValue();
            }
            $metadata[$i]['name'] = $param->name;
            $metadata[$i++]['optional'] = $param->isOptional();
        }
        return $metadata;
    }
}
