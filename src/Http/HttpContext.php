<?php
/*
 * (c) Leonardo Brugnara
 *
 * Full copyright and license information in LICENSE file.
 */

namespace Gekko\Http;

use Gekko\Config\ConfigProvider;
use Gekko\Config\IConfigProvider;
use \Gekko\DependencyInjection\{DependencyInjector,IDependencyInjector};
use Gekko\Env;

final class HttpContext implements IHttpContext
{
    /**
     * List of closures/invokables to be called when HttpContext dispatch an HttpRequest
     *
     * @var \Closure
     */
    protected $middlewares;

    /**
     * Reference to the Router class to enroute HTTP requests
     *
     * @var \Gekko\Http\Routing\Router
     */
    protected $router;

    /**
     * Dependency Injector class used to resolve dependencies in
     * HttpMiddleware middleware
     *
     * @var \Gekko\DependencyInjection\IDependencyInjector
     */
    protected $injector;

    /**
     * Configuration provider
     * 
     * @var \Gekko\Config\IConfigProvider
     */
    protected $config_provider;


    public function __construct()
    {
        $this->middlewares = [];

        $this->injector = new DependencyInjector();
        $this->router = new Routing\Router($this->injector);

        $this->injector->getContainer()->add(IHttpContext::class, ['reference' => $this]);

        $configPath = Env::toLocalPath(Env::get("config.path") ?? "config");

        $this->config_provider = new ConfigProvider(Env::get("config.driver") ?? "php", Env::get("config.env"), $configPath);
        
        // Register the config provider
        $this->injector->getContainer()->add(IConfigProvider::class, [ "reference" => $this->config_provider ]);
    }

    
    public function configure(IDependencyInjector $di)
    {
        // do nothing   
    }

    public function onInit()
    {
        // do nothing
    }

    /**
     * HttpContext lifecycle:
     *  onInit
     *  dispatch (all the registered middleware are invoked here)
     *  onFinish
     */
    public function run()
    {
        // Call the onInit method to let HttpContext to bootstrap
        $this->onInit();
        
        // Preprend the Router to be the first middleware
        \array_unshift($this->middlewares, $this->router);

        // HttpContext use an HttpMiddleware to dispatch the request based on the routing made by Router
        $this->addMiddleware(new HttpMiddleware($this->injector));

        // Capture all the output generated by outside of the HttpResponse object and show it only if the request has a gdebug parameter
        ob_start();

        // Create the HttpRequest object that contains all the information of the current request
        $request = new HttpRequest();

        // Call dispatch here to pass the request through all the middlewares
        $response = $this->dispatch($request);

        // Consume all the output that do not belong to the response and show it just if "gdebug" is defined
        $outbuff = ob_get_clean();
        
        if ($request->hasParameter("gdebug")) {
            echo $outbuff;
        }

        // With the buffer cleaned, show the response
        echo $response;

        // Call the onFinish method to let HttpContext make the clean up
        $this->onFinish();
    }

    /**
     * Enroutes the HttpRequest and then dispatches the request making it passing through the middleware's pipeline
     */
    public function dispatch(IHttpRequest $request) : IHttpResponse
    {
        // The response contains all the methods needed to add/append the output for the current HttpRequest
        $response = new HttpResponse();

        // Make the HttpRequest and HttpResponse available through dependency injection.
        // Each dependency to be resolved when the param is one of this two objects,
        // will receive a reference to the current request and response objects
        $this->injector->getContainer()->add(IHttpRequest::class, [
            'reference' => $request
        ]);
        
        $this->injector->getContainer()->add(IHttpResponse::class, [
            'reference' => $response
        ]);

        // Get the middlewares
        $queue = $this->middlewares;

        // Create $next, a function that runs every middleware in the queue
        $next = function (IHttpRequest $req, IHttpResponse $resp) use (&$queue, &$next) {
            // Get the next middleware
            $middl = array_shift($queue);

            // If there is no middleware, return the HTTP response
            if ($middl == null) {
                return $resp;
            }

            // Call the middleware passing the HttpRequest, HttpResponse
            // and the $next function so the current middleware can
            // invoke the next one
            return $middl($req, $resp, $next);
        };

        // Invoke the first middleware
        return $next($request, $response);
    }

    public function onFinish()
    {
    }

    // Adds a middleware to the pipeline
    public function addMiddleware($middleware)
    {
        if (!is_callable($middleware)) {
            throw new Exception("Middleware is not callable", 1);
        }
        $this->middlewares[] = $middleware;
        return $this;
    }

    /* -------------------------------------------------------------
     * App Services
     * -------------------------------------------------------------
     */
    public function getRouter() : Routing\Router
    {
        return $this->router;
    }

    public function getInjector() : IDependencyInjector
    {
        return $this->injector;
    }
}
