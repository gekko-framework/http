<?php
/*
 * (c) Leonardo Brugnara
 *
 * Full copyright and license information in LICENSE file.
 */

namespace Gekko\Http;

use Gekko\Config\ConfigProvider;
use Gekko\Config\IConfigProvider;
use \Gekko\DependencyInjection\{DependencyInjector,IDependencyInjector};
use Gekko\Env;

final class HttpContext implements IHttpContext
{
    /**
     * List of closures/invokables to be called when HttpContext dispatch an HttpRequest
     *
     * @var \Closure
     */
    protected $middlewares;

    /**
     * Reference to the Router class to enroute HTTP requests
     *
     * @var \Gekko\Http\Routing\Router
     */
    protected $router;

    /**
     * Dependency Injector class used to resolve dependencies
     *
     * @var \Gekko\DependencyInjection\IDependencyInjector
     */
    protected $injector;

    /**
     * Configuration provider
     * 
     * @var \Gekko\Config\IConfigProvider
     */
    protected $config_provider;


    public function __construct()
    {
        $this->middlewares = [];

        $this->injector = new DependencyInjector();
        $this->router = new Routing\Router($this->injector);

        $this->injector->getContainer()->add(IHttpContext::class, ['reference' => $this]);

        $configPath = Env::toLocalPath(Env::get("config.path") ?? "config");

        $this->config_provider = new ConfigProvider(Env::get("config.driver") ?? "php", Env::get("config.env"), $configPath);
        
        // Register the config provider
        $this->injector->getContainer()->add(IConfigProvider::class, [ "reference" => $this->config_provider ]);
    }

    
    public function configure(IDependencyInjector $di)
    {
        // do nothing   
    }

    public function onInit()
    {
        // do nothing
    }

    /**
     * HttpContext lifecycle:
     *  onInit
     *  dispatch (all the registered middleware are invoked here)
     *  onFinish
     */
    public function run()
    {
        // Call the onInit method to let HttpContext to bootstrap
        $this->onInit();
        
        // Preprend the Router to be the first middleware
        \array_unshift($this->middlewares, $this->router);

        // HttpContext use an IHttpMiddleware to dispatch the request based on the routing made by Router
        $this->addMiddleware(new HttpDispatchMiddleware($this->injector));

        // Capture all the output generated by outside of the HttpResponse object and show it only if the request has a gdebug parameter
        ob_start();

        // Create the HttpRequest object that contains all the information of the current request
        $request = $this->createHttpRequest();

        // Call dispatch here to pass the request through all the middlewares
        $response = $this->dispatch($request);

        // Consume all the output that do not belong to the response
        ob_get_clean();        

        // Write the response status line
        header($response->getStatusLine());

        // Set the headers
        foreach ($response->getHeaders() as $header => $value)
            header("{$header}: $value");

        // Include set-cookie headers
        foreach ($response->getCookies() as $cookie) 
            header("set-cookie: {$cookie}");

        // Echo the response's body
        echo $response->getBody();

        // Call the onFinish method to let HttpContext make the clean up
        $this->onFinish();
    }

    /**
     * Enroutes the HttpRequest and then dispatches the request making it passing through the middleware's pipeline
     */
    public function dispatch(IHttpRequest $request) : IHttpResponse
    {
        // The response contains all the methods needed to add/append the output for the current HttpRequest
        $response = new HttpResponse();

        // Make the HttpRequest and HttpResponse available through dependency injection.
        // Each dependency to be resolved when the param is one of this two objects,
        // will receive a reference to the current request and response objects
        $this->injector->getContainer()->add(IHttpRequest::class, [
            'reference' => $request
        ]);
        
        $this->injector->getContainer()->add(IHttpResponse::class, [
            'reference' => $response
        ]);

        // Get the middlewares
        $queue = $this->middlewares;

        // Create $next, a function that runs every middleware in the queue
        $next = function (IHttpRequest $req, IHttpResponse $resp) use (&$queue, &$next) {
            // Get the next middleware
            $next_middleware = array_shift($queue);

            // If there are no more middlewares, return the processed response
            if ($next_middleware == null)
                return $resp;

            // Call the middleware passing the HttpRequest, HttpResponse
            // and the $next function so the current middleware can
            // invoke the next one
            return $next_middleware->apply($req, $resp, $next);
        };

        // Invoke the first middleware
        return $next($request, $response);
    }

    public function onFinish()
    {
    }

    // Adds a middleware to the pipeline
    public function addMiddleware($middleware)
    {
        if (is_callable($middleware))
        {
            $middleware = new HttpAnonymousMiddleware($middleware);
        }
        else if (is_string($middleware) && class_exists($middleware) && in_array(IHttpMiddleware::class, class_implements($middleware)))
        {
            $middleware = $this->injector->make($middleware);
        }
        else if (!($middleware instanceof IHttpMiddleware))
        {
            throw new \Exception("Middleware is not callable", 1);
        }
        
        $this->middlewares[] = $middleware;
        return $this;
    }

    /* -------------------------------------------------------------
     * App Services
     * -------------------------------------------------------------
     */
    public function getRouter() : Routing\Router
    {
        return $this->router;
    }

    public function getInjector() : IDependencyInjector
    {
        return $this->injector;
    }

    protected function createHttpRequest() : IHttpRequest
    {
        // VERB
        $method = filter_input(INPUT_SERVER, 'REQUEST_METHOD', FILTER_SANITIZE_SPECIAL_CHARS);

        // URI
        // We don't want virtual path here as the REQUEST_URI should contain it
        $hostname = $this->resolveHostname(false);
        $request_uri = strtok(filter_input(INPUT_SERVER, 'REQUEST_URI', FILTER_SANITIZE_SPECIAL_CHARS), '?');
        $query = isset($_SERVER['QUERY_STRING']) ? $_SERVER['QUERY_STRING'] : '';
        $uri = new URI($hostname . $request_uri . (empty($query) ? "" : "?{$query}"));

        // HEADERS
        $headers = apache_request_headers();

        // PROTOCOL
        $server_protocol = filter_input(INPUT_SERVER, 'SERVER_PROTOCOL', FILTER_SANITIZE_URL);
        $request_protocol = HttpRequest::PROTO_VER_1_1;

        if (strpos($server_protocol, "/2") !== false)
            $request_protocol = HttpRequest::PROTO_VER_2_0;
        else if (strpos($server_protocol, "/1.0") !== false)
            $request_protocol = HttpRequest::PROTO_VER_1_0;

        // BODY
        $body = file_get_contents("php://input");

        // COOKIES
        $cookies = $_COOKIE;

        // FILES
        $files = $this->processFiles();

        return new HttpRequest($method, $uri, $headers, $request_protocol, $body !== false ? $body : "", $cookies, $files);
    }

    protected function resolveHostname(bool $with_virtual_path = true) : string
    {
        $scheme = filter_input(INPUT_SERVER, 'REQUEST_SCHEME', FILTER_SANITIZE_URL);
        $port = filter_input(INPUT_SERVER, 'SERVER_PORT', FILTER_SANITIZE_URL);
        $server_protocol = filter_input(INPUT_SERVER, 'SERVER_PROTOCOL', FILTER_SANITIZE_URL);
        $host = filter_input(INPUT_SERVER, 'HTTP_HOST', FILTER_SANITIZE_URL);
        $virtual_path = $with_virtual_path ? Env::get("site.virtual_path") : "";
        
        if ($with_virtual_path && strlen($virtual_path) > 0)
        {
            if ($virtual_path[0] != '/')
                $virtual_path = "/" . $virtual_path;
            
            if ($virtual_path[strlen($virtual_path)-1] == '/')
                $virtual_path = \substr($virtual_path, 0, strlen($virtual_path) - 1);
        }
            
        
        if (empty($scheme)) {
            $server_protocol = explode('/', $server_protocol);
            if (intval($port) == 443 || strtolower($server_protocol[0]) === "https") {
                $scheme = "https";
            } else {
                $scheme = "http";
            }
        }

        return "{$scheme}://{$host}{$virtual_path}";
    }

    protected function processFiles() : array
    {
        if (empty($_FILES)) {
            return [];
        }
        $files = $_FILES;
        $newFiles = [];
        // a mapping of $_FILES indices for validity checking
        foreach ($files as $inputName => $data) {
            foreach ($data as $key => $value) {
                if (is_array($value)) {
                    foreach ($value as $i => $v) {
                        $newFiles[$inputName][$i][$key] = $v;
                    }
                } else {
                    $newFiles[$inputName][$key] = $value;
                }
            }
        }

        return $newFiles;
    }
}
